# Workflow: PR Body Guardrails for EPIC Issues
#
# Purpose: Prevents accidental auto-closure of EPIC issues (parent/epic tracking
# issues with "EPIC" in title) when PRs are merged. EPICs track large bodies of
# work and should not be auto-closed by individual PRs. This workflow:
# 1. Normalizes PR body: Rewrites "closes/fixes/resolves" to "Refs" for EPIC issues
# 2. Validates: Scans PR title, body, and commits to ensure no auto-close keywords
#    remain for EPIC issues after normalization
#
# Auto-close keywords: close, closes, closed, fix, fixes, fixed, resolve, resolves, resolved
# Acceptable keywords: Refs, Related, Tracks (do not auto-close)
#
# Triggers:
# - Pull requests: opened, edited, synchronize, reopened, ready_for_review
#
# Dependencies:
# - actions/github-script@v7 (for GitHub API access)
# - GitHub token (provided by GITHUB_TOKEN)
#
# Outputs:
# - Status check: "normalize-and-check"
# - Artifacts: None
# - Side effects: May update PR body to normalize EPIC references
#
# Notes:
# - Required for merge
# - Exit 0 = no auto-close keywords for EPICs, non-zero = violations detected
---
name: pr-body-guardrails

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]

jobs:
  # Job: Normalize and Check PR Body
  # Two-phase approach: normalize (rewrite auto-close keywords) then validate
  check:
    name: normalize-and-check
    # Runner: Ubuntu latest (sufficient for GitHub API calls and shell scripting)
    runs-on: ubuntu-latest
    # Permissions:
    # - pull-requests: write - Required to update PR body in normalization step
    # - contents: read - Required for API reads (fetch issue metadata, PR details)
    permissions:
      pull-requests: write   # needed for PR body update in normalize step
      contents: read         # needed for API reads
    steps:
      # Step 1: Normalize PR body (non-fork PRs only)
      # Rewrites auto-close keywords to "Refs" for issues with "EPIC" in title
      # Uses GitHub Actions script context with in-memory caching to reduce API calls
      # Skips fenced code blocks (```/~~~) to avoid breaking code examples
      # Fork PRs are skipped because they lack write permissions
      - name: Normalize PR body (non-fork only)
        if: github.event.pull_request.head.repo.fork == false
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || "";

            // In-memory cache for issue metadata lookups
            const issueCache = new Map();

            // Fetch issue metadata to check if title contains "EPIC" (case-insensitive) as a whole word
            async function isEpicIssue(owner, repo, issueNum) {
              const cacheKey = `${owner}/${repo}#${issueNum}`;

              if (issueCache.has(cacheKey)) {
                return issueCache.get(cacheKey);
              }

              try {
                const { data: issue } = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: issueNum,
                });
                // Use word boundary regex to match "EPIC" as a whole word only
                const title = issue.title || "";
                const result = /\bEPIC\b/i.test(title);
                issueCache.set(cacheKey, result);
                return result;
              } catch (error) {
                core.warning(`Failed to fetch issue #${issueNum}: ${error.message}`);
                issueCache.set(cacheKey, false);
                return false;
              }
            }

            // Extract all issue references from text to check which have "EPIC" in title
            // Uses bounded concurrency to avoid overwhelming the API
            async function getEpicIssueNumbers(text, owner, repo) {
              const issuePattern = /(?<![A-Za-z0-9_.-])(?:([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+))?#(\d+)\b/g;
              const epicIssues = new Set();
              const checks = [];
              let match;

              while ((match = issuePattern.exec(text)) !== null) {
                const repoPrefix = match[1];
                const issueNum = parseInt(match[2], 10);

                // Determine the target repo
                let targetOwner = owner;
                let targetRepo = repo;
                if (repoPrefix) {
                  const parts = repoPrefix.split('/');
                  if (parts.length === 2) {
                    targetOwner = parts[0];
                    targetRepo = parts[1];
                  }
                }

                // Queue the check (will use cache if available)
                checks.push({
                  ref: `${repoPrefix || ""}#${issueNum}`,
                  owner: targetOwner,
                  repo: targetRepo,
                  num: issueNum
                });
              }

              // Process checks with bounded concurrency (pool size 5)
              const poolSize = 5;
              for (let i = 0; i < checks.length; i += poolSize) {
                const batch = checks.slice(i, i + poolSize);
                const results = await Promise.all(
                  batch.map(c => isEpicIssue(c.owner, c.repo, c.num).then(isEpic => ({ ref: c.ref, isEpic })))
                );
                results.forEach(r => {
                  if (r.isEpic) {
                    epicIssues.add(r.ref);
                  }
                });
              }

              return epicIssues;
            }

            // Get issue numbers with "EPIC" in title from the body
            const epicIssues = await getEpicIssueNumbers(body, context.repo.owner, context.repo.repo);

            if (epicIssues.size === 0) {
              core.notice("No issues with 'EPIC' in title found in PR body.");
              return;
            }

            core.notice(`Found ${epicIssues.size} issue(s) with 'EPIC' in title: ${Array.from(epicIssues).join(', ')}`);

            // Split body into segments, tracking code fences
            async function normalizeOutsideCodeFences(text, epicIssues) {
              const lines = text.split('\n');
              let inCodeFence = false;
              const result = [];

              // Build a combined regex pattern for all epic issues to avoid O(n*m) complexity
              let combinedPattern = null;
              if (epicIssues.size > 0) {
                const escapedRefs = Array.from(epicIssues).map(ref =>
                  ref.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                );
                const refsAlternation = escapedRefs.join('|');
                // Deterministic format: always rewrite to "Refs " (no colon)
                combinedPattern = new RegExp(
                  `(\\b)(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)(?::\\s*|\\s+)(${refsAlternation})\\b`,
                  'gi'
                );
              }

              for (let line of lines) {
                // Check for code fence markers (``` or ~~~), allowing up to 3 spaces of indentation
                if (/^\s{0,3}(```|~~~)/.test(line)) {
                  inCodeFence = !inCodeFence;
                  result.push(line);
                  continue;
                }

                if (inCodeFence) {
                  // Inside code fence - preserve as-is
                  result.push(line);
                } else if (combinedPattern) {
                  // Outside code fence - apply normalization for issues with "EPIC" in title
                  // Always use deterministic format: "Refs " (no colon)
                  const normalized = line.replace(combinedPattern, (m, p1, kw, ref) => {
                    return `${p1}Refs ${ref}`;
                  });
                  result.push(normalized);
                } else {
                  result.push(line);
                }
              }

              return result.join('\n');
            }

            const rewritten = await normalizeOutsideCodeFences(body, epicIssues);

            if (rewritten !== body) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                body: rewritten,
              });
              core.notice("PR body updated to remove auto-close keywords for issues with 'EPIC' in title.");
            } else {
              core.notice("No auto-close keywords found for issues with 'EPIC' in title in PR body.");
            }

      # Step 2: Install jq dependency
      # Required for JSON parsing in bash validation script
      - name: Install dependencies
        run: |
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            sudo apt-get update -qq
            sudo apt-get install -y jq
          else
            echo "jq is already installed"
          fi

      # Step 3: Scan PR title, body, and commits for auto-close keywords
      # Validates that the normalization step successfully removed all auto-close
      # keywords for EPIC issues. Fails the workflow if any are found.
      # Uses bash script with associative array caching for issue title lookups.
      # Sanitizes PR body by removing "Original prompt" section and code fences.
      # Environment variables: OWNER, REPO, PR_NUMBER (from GitHub context)
      - name: Scan PR title/body and commits for auto-close keywords
        env:
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          fail() { echo "::error::$1"; exit 1; }

          # Associative array cache for issue title lookups
          declare -A EPIC_CACHE

          # Function to check if an issue has "EPIC" in the title (case-insensitive) as a whole word
          # Returns: 0 if EPIC found, 1 if not found, 2 if API error
          has_epic_in_title() {
            local issue_num="$1"
            local issue_owner="${2:-$OWNER}"
            local issue_repo="${3:-$REPO}"
            local cache_key="${issue_owner}/${issue_repo}#${issue_num}"

            # Check cache first
            if [[ -v "EPIC_CACHE[$cache_key]" ]]; then
              [[ "${EPIC_CACHE[$cache_key]}" == "true" ]] && return 0 || return 1
            fi

            if ! issue_json=$(curl -sSf \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$issue_owner/$issue_repo/issues/$issue_num" 2>&1); then
              echo "::warning::Failed to fetch issue #$issue_num: $issue_json" >&2
              EPIC_CACHE[$cache_key]="false"
              return 2  # API error
            fi

            # Check if title contains "EPIC" as a whole word (case-insensitive)
            local title
            title=$(echo "$issue_json" | jq -r '.title // ""') || return 2
            if echo "$title" | grep -iw "EPIC" > /dev/null 2>&1; then
              EPIC_CACHE[$cache_key]="true"
              return 0  # EPIC found
            else
              EPIC_CACHE[$cache_key]="false"
              return 1  # Not an EPIC issue
            fi
          }

          # Function to extract issue numbers and check if they have "EPIC" in title
          get_epic_issue_refs() {
            local text="$1"
            local in_code_block=0
            local FENCE_RE='^[[:space:]]{0,3}(```|~~~)'

            # Extract all issue references (#number or owner/repo#number)
            while read -r line; do
              # Skip fenced code blocks (``` or ~~~), allowing up to 3 spaces of indentation
              if [[ "$line" =~ $FENCE_RE ]]; then
                in_code_block=$((1 - in_code_block))
                continue
              fi

              # If inside a fenced code block, skip this line
              if [[ "$in_code_block" -eq 1 ]]; then
                continue
              fi

              # Match issue references: optional repo prefix + # + number
              # Use Perl regex with negative lookbehind to match JS behavior
              refs=$(echo "$line" | grep -Po '(?<![[:alnum:]_.-])([[:alnum:]_.-]+/[[:alnum:]_.-]+)?#[0-9]+' || true)
              if [[ -z "$refs" ]]; then
                continue
              fi

              echo "$refs" | while read -r ref; do
                # Parse the reference
                if [[ "$ref" =~ ^([[:alnum:]_.-]+)/([[:alnum:]_.-]+)\#([0-9]+)$ ]]; then
                  # Cross-repo reference
                  local ref_owner="${BASH_REMATCH[1]}"
                  local ref_repo="${BASH_REMATCH[2]}"
                  local ref_num="${BASH_REMATCH[3]}"

                  # Capture return code without triggering set -e
                  local ret=0
                  has_epic_in_title "$ref_num" "$ref_owner" "$ref_repo" || ret=$?
                  if [[ $ret -eq 0 ]]; then
                    echo "$ref"
                  fi
                  # ret=1 means not epic, ret=2 means API error (already warned)
                elif [[ "$ref" =~ ^\#([0-9]+)$ ]]; then
                  # Same-repo reference
                  local ref_num="${BASH_REMATCH[1]}"

                  # Capture return code without triggering set -e
                  local ret=0
                  has_epic_in_title "$ref_num" "$OWNER" "$REPO" || ret=$?
                  if [[ $ret -eq 0 ]]; then
                    echo "$ref"
                  fi
                  # ret=1 means not epic, ret=2 means API error (already warned)
                fi
              done
            done <<< "$text"
          }

          # Function to build pattern for issues with "EPIC" in title
          build_epic_pattern() {
            local epic_refs="$1"

            if [ -z "$epic_refs" ]; then
              echo ""
              return
            fi

            # Build alternation pattern for all epic issue references
            local pattern_parts=""
            while IFS= read -r ref; do
              # Escape special regex characters
              local escaped_ref
              escaped_ref=$(echo "$ref" | sed 's/[][\\.^$*+?{}()|]/\\&/g') || escaped_ref="$ref"
              if [ -n "$pattern_parts" ]; then
                pattern_parts="${pattern_parts}|${escaped_ref}"
              else
                pattern_parts="$escaped_ref"
              fi
            done <<< "$epic_refs"

            # Build full pattern: keyword + optional colon + optional space + (epic refs)
            # Match the same format as JS normalization
            echo '\b(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)' \
              '(:[[:space:]]*|[[:space:]]+)('"$pattern_parts"')\b'
          }

          sanitize_body() {
            # Remove auto-generated "Original prompt" section and code fences
            awk 'BEGIN { drop=0; in_fence=0 }
              /^Original prompt[[:space:]]*$/ { drop=1; in_fence=0; next }
              drop { next }
              /^[[:space:]]{0,3}(```|~~~)/ { in_fence = (in_fence ? 0 : 1); next }
              in_fence { next }
              { print }'
          }

          # Fetch the UPDATED PR body from the API (after normalization step has run).
          # Use a short retry loop to reduce the chance of seeing a stale body due to
          # eventual consistency in the GitHub API under load.
          PR_BODY=""
          for attempt in 1 2 3; do
            if ! PR_BODY_JSON=$(curl -sSf \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO/pulls/$PR_NUMBER" 2>&1); then
              fail "Failed to fetch PR body from GitHub API: $PR_BODY_JSON"
            fi

            PR_BODY=$(echo "$PR_BODY_JSON" | jq -r '.body // ""') || PR_BODY=""
            PR_TITLE=$(echo "$PR_BODY_JSON" | jq -r '.title // ""') || PR_TITLE=""

            # Give GitHub a brief moment to propagate the updated body between attempts.
            if [ "$attempt" -lt 3 ]; then
              sleep 2
            fi
          done

          body="$(printf '%s' "$PR_BODY" | sanitize_body)"

          # Get all issue references with "EPIC" in title from PR body
          echo "Checking for issues with 'EPIC' in title in PR body..."
          epic_issue_refs=$(get_epic_issue_refs "$body") || epic_issue_refs=""

          if [ -z "$epic_issue_refs" ]; then
            echo "No issues with 'EPIC' in title found in PR body."
          else
            echo "Found issues with 'EPIC' in title:"
            echo "$epic_issue_refs"

            # Build pattern for epic issues
            EPIC_PATTERN=$(build_epic_pattern "$epic_issue_refs") || EPIC_PATTERN=""

            if [ -n "$EPIC_PATTERN" ]; then
              # Check PR title
              if matched_line=$(printf '%s' "$PR_TITLE" | grep -Ei "$EPIC_PATTERN"); then
                # Extract which issue was matched
                matched_issue=$(echo "$matched_line" | \
                  grep -Eo '(#[0-9]+|[[:alnum:]_.-]+/[[:alnum:]_.-]+#[0-9]+)' | head -1)
                fail "Auto-close keyword found in PR TITLE for EPIC issue $matched_issue." \
                     " Use Refs/Related/Tracks instead. Matched text: $matched_line"
              fi

              # Check PR body
              if matched_line=$(printf '%s' "$body" | grep -Ei "$EPIC_PATTERN" | head -1); then
                # Extract which issue was matched
                matched_issue=$(echo "$matched_line" | \
                  grep -Eo '(#[0-9]+|[[:alnum:]_.-]+/[[:alnum:]_.-]+#[0-9]+)' | head -1)
                fail "Auto-close keyword found in PR BODY for EPIC issue $matched_issue" \
                     " (excluding 'Original prompt' block). Use Refs/Related/Tracks instead." \
                     " Matched line: $matched_line"
              fi

              # Check commit messages
              base_commits_api="https://api.github.com/repos/$OWNER/$REPO/pulls/$PR_NUMBER/commits"
              page=1
              while :; do
                commits_api="${base_commits_api}?per_page=100&page=${page}"
                if ! commits_json="$(curl -sSf \
                  -H "Authorization: Bearer $GH_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "$commits_api" 2>&1)"; then
                  fail "Failed to fetch commits from GitHub API: $commits_json"
                fi

                commit_messages="$(echo "$commits_json" | jq -r '.[].commit.message')" || commit_messages=""
                [ -z "$commit_messages" ] && break

                if matched_line=$(printf '%s\n' "$commit_messages" | \
                    grep -Ei "$EPIC_PATTERN" | head -1); then
                  # Extract which issue was matched
                  matched_issue=$(echo "$matched_line" | \
                    grep -Eo '(#[0-9]+|[[:alnum:]_.-]+/[[:alnum:]_.-]+#[0-9]+)' | head -1)
                  # Try to find which commit contains this
                  matched_commit=$(echo "$commits_json" | \
                    jq -r --arg msg "$matched_line" \
                    '.[] | select(.commit.message | contains($msg)) | .sha[:7]' | head -1)
                  fail "Auto-close keyword found in COMMIT $matched_commit for EPIC issue" \
                       " $matched_issue. Amend/reword commit(s) to use Refs/Related/Tracks instead." \
                       " Matched line: $matched_line"
                fi

                page_count="$(echo "$commits_json" | jq 'length')"
                [ "$page_count" -lt 100 ] && break
                page=$((page + 1))
              done
            fi
          fi

          echo "OK: No auto-close keywords detected for issues with 'EPIC' in title (title/body/commits)."

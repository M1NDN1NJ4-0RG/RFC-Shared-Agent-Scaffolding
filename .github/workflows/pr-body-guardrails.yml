name: pr-body-guardrails

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]

permissions:
  pull-requests: write   # needed for PR body update
  contents: read         # scan job reads commits

jobs:
  normalize:
    if: github.event.pull_request.head.repo.fork == false
    runs-on: ubuntu-latest
    steps:
      - name: Rewrite auto-close keywords in PR body
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || "";

            // Split body into segments, tracking code fences
            function normalizeOutsideCodeFences(text) {
              const lines = text.split('\n');
              let inCodeFence = false;
              const result = [];

              for (let line of lines) {
                // Check for code fence markers (``` or ~~~)
                if (/^```|^~~~/.test(line)) {
                  inCodeFence = !inCodeFence;
                  result.push(line);
                  continue;
                }

                if (inCodeFence) {
                  // Inside code fence - preserve as-is
                  result.push(line);
                } else {
                  // Outside code fence - apply normalization
                  // Match: keyword + optional colon + optional space + repo? + #number
                  const normalized = line.replace(
                    /(\b)(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)(:?\s*)([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)?#(\d+)\b/gi,
                    (m, p1, kw, punctSpace, repoPrefix, num) => {
                      // Preserve spacing style (use space if there was any whitespace)
                      const space = /\s/.test(punctSpace) ? ' ' : punctSpace.replace(':', '') || ' ';
                      return `${p1}Refs${space}${repoPrefix || ""}#${num}`;
                    }
                  );
                  result.push(normalized);
                }
              }

              return result.join('\n');
            }

            const rewritten = normalizeOutsideCodeFences(body);

            if (rewritten !== body) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                body: rewritten,
              });
              core.notice("PR body updated to remove auto-close keywords.");
            } else {
              core.notice("No auto-close keywords found in PR body.");
            }

  check:
    name: no-autoclose-keywords
    runs-on: ubuntu-latest
    needs: normalize
    steps:
      - name: Install dependencies
        run: |
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            sudo apt-get update -qq
            sudo apt-get install -y jq
          else
            echo "jq is already installed"
          fi

      - name: Scan PR title/body and commits for auto-close keywords
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          # Match keyword + optional colon + optional space + repo? + #number
          PATTERN='\b(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved):?[[:space:]]*([[:alnum:]_.-]+\/[[:alnum:]_.-]+)?#([0-9]+)\b'
          fail() { echo "::error::$1"; exit 1; }

          sanitize_body() {
            # Remove auto-generated "Original prompt" section more robustly
            # Look for the pattern: a separator line (----) followed by "Original prompt"
            # This matches GitHub's auto-appended format more precisely
            awk '
              BEGIN { drop=0 }
              # Match separator followed by "Original prompt" (with optional whitespace)
              /^----[[:space:]]*$/ {
                # Peek ahead - if next line is "Original prompt", start dropping
                getline nextline
                if (nextline ~ /^Original prompt[[:space:]]*$/) {
                  drop=1
                } else {
                  # False alarm - print both lines
                  if (!drop) {
                    print
                    print nextline
                  }
                }
                next
              }
              # Also catch "Original prompt" without separator for backward compat
              # but only if it appears to be at the end (no content after)
              /^Original prompt[[:space:]]*$/ {
                # Check if this looks like an auto-generated delimiter
                # by seeing if we're near the end of content
                drop=1
                next
              }
              { if (!drop) print }
            '
          }

          title="$PR_TITLE"
          body="$(printf '%s' "$PR_BODY" | sanitize_body)"

          printf '%s' "$title" | grep -Eiq "$PATTERN" && fail "Auto-close keyword found in PR TITLE. Use Refs/Related/Tracks instead."
          printf '%s' "$body"  | grep -Eiq "$PATTERN" && fail "Auto-close keyword found in PR BODY (excluding 'Original prompt' block). Use Refs/Related/Tracks instead."

          base_commits_api="https://api.github.com/repos/$OWNER/$REPO/pulls/$PR_NUMBER/commits"
          page=1
          while :; do
            commits_api="${base_commits_api}?per_page=100&page=${page}"
            commits_json="$(curl -sSf \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "$commits_api")"

            commit_messages="$(echo "$commits_json" | jq -r '.[].commit.message')"
            [ -z "$commit_messages" ] && break

            printf '%s\n' "$commit_messages" | grep -Eiq "$PATTERN" \
              && fail "Auto-close keyword found in a COMMIT message in this PR. Amend/reword commit(s) to use Refs/Related/Tracks."

            page_count="$(echo "$commits_json" | jq 'length')"
            [ "$page_count" -lt 100 ] && break
            page=$((page + 1))
          done

          echo "OK: No auto-close keywords detected (title/body/commits)."

# Workflow: Drift Detection Gate
#
# Purpose: Detects behavioral drift between language-specific implementations
# (bash, python3, perl) of the safe-run wrapper. Ensures all implementations
# exhibit identical behavior for the same inputs, validating:
# - Exit codes match across implementations
# - Artifact creation (FAIL-LOGS) is consistent
# - Log file format follows M0-P1-I1 and M0-P1-I2 standards
#
# Triggers:
# - Pull requests modifying language bundles, conformance data, or this workflow
# - Pushes to main branch affecting the same paths
# - Manual workflow dispatch
#
# Note: This runs on Linux (ubuntu-latest) and tests bash/python3/perl.
# PowerShell tests run separately on Windows runner (test-powershell.yml).
name: Drift Detection Gate

on:
  pull_request:
    paths:
      - 'RFC-Shared-Agent-Scaffolding-Example/scripts/**'
      - 'conformance/**'
      - '.github/workflows/drift-detection.yml'
  push:
    branches:
      - main
    paths:
      - 'RFC-Shared-Agent-Scaffolding-Example/scripts/**'
      - 'conformance/**'
  workflow_dispatch:

# Permissions: Read-only access to repository contents
permissions:
  contents: read

jobs:
  # Job: Cross-Language Drift Detection
  # Runs identical test vectors against bash, python3, and perl implementations
  # to verify behavioral parity. Drift indicates a bug or unintended divergence.
  detect-drift:
    name: Cross-Language Drift Detection
    # Runner: Ubuntu latest (provides bash, python3, perl, and Rust toolchain)
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Checkout repository to access all language implementations
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Step 2: Install Rust stable toolchain for building the canonical safe-run binary
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
      
      # Step 3: Build the Rust canonical tool in release mode
      # This is the reference implementation that wrappers delegate to
      - name: Build Rust canonical tool
        run: |
          cd rust
          cargo build --release
          cd ..
      
      # Step 4: Stage the Rust binary at dist/linux/x86_64/safe-run
      # This is the standard location where wrappers discover the canonical binary
      # via the SAFE_RUN_BIN environment variable
      - name: Stage Rust binary for wrapper discovery
        run: |
          mkdir -p dist/linux/x86_64
          cp rust/target/release/safe-run dist/linux/x86_64/safe-run
          chmod +x dist/linux/x86_64/safe-run
          echo "Rust binary staged at: dist/linux/x86_64/safe-run"
          ls -lh dist/linux/x86_64/safe-run
      
      # Step 5: Install test environment dependencies
      # - jq: Required by Bash wrapper for conformance vector parsing
      # - python3: Already available on ubuntu-latest
      # - perl: Already available on ubuntu-latest
      - name: Set up test environments
        run: |
          # Install jq for Bash
          sudo apt-get update
          sudo apt-get install -y jq
          
          # Verify jq
          jq --version
          
          # Python 3 (already available on ubuntu-latest)
          python3 --version
          
          # Perl (already available on ubuntu-latest)
          perl --version
      
      # Step 6: Install Perl environment and dependencies
      # Uses shogo82148/actions-setup-perl for consistent Perl 5.38 setup
      - name: Install Perl dependencies
        uses: shogo82148/actions-setup-perl@3e011cd23aec3d977e118dfe36ba1318b28b63ef # v1
        with:
          perl-version: '5.38'
      
      # Step 7: Validate conformance/vectors.json is valid JSON
      # This file contains the canonical test vectors shared across all implementations
      - name: Validate conformance vectors
        run: |
          echo "Validating conformance/vectors.json..."
          if ! jq empty conformance/vectors.json; then
            echo "❌ ERROR: conformance/vectors.json is not valid JSON"
            exit 1
          fi
          echo "✅ Conformance vectors valid"
      
      # Step 8: Run drift detection for safe-run-001 test vector
      # Test case: Success scenario (exit 0, no artifacts created)
      # Validates: Exit codes all 0, no FAIL-LOGS directory created
      - name: Run drift detection - safe-run-001 (success case)
        id: drift-safe-run-001
        run: |
          echo "========================================="
          echo "Testing: safe-run-001 (success produces no artifacts)"
          echo "========================================="
          
          mkdir -p /tmp/drift-test
          cd /tmp/drift-test
          
          # Set SAFE_RUN_BIN for wrapper discovery (scripts run from outside repo)
          export SAFE_RUN_BIN="${GITHUB_WORKSPACE}/dist/linux/x86_64/safe-run"
          
          # Note: Script paths include 'scripts' subdirectory in each bundle
          # Structure: RFC-Shared-Agent-Scaffolding-Example/scripts/<lang>/scripts/<script>
          
          # Test Bash
          echo "Testing Bash implementation..."
          bash_exit=0
          bash "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/bash/scripts/safe-run.sh" echo "ok" > /tmp/bash-out.txt 2>&1 || bash_exit=$?
          bash_artifacts=$(ls .agent/FAIL-LOGS/ 2>/dev/null | wc -l || echo 0)
          rm -rf .agent
          
          # Test Python 3
          echo "Testing Python 3 implementation..."
          python_exit=0
          python3 "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/python3/scripts/safe-run.py" echo "ok" > /tmp/python-out.txt 2>&1 || python_exit=$?
          python_artifacts=$(ls .agent/FAIL-LOGS/ 2>/dev/null | wc -l || echo 0)
          rm -rf .agent
          
          # Test Perl
          echo "Testing Perl implementation..."
          perl_exit=0
          perl "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/perl/scripts/safe-run.pl" echo "ok" > /tmp/perl-out.txt 2>&1 || perl_exit=$?
          perl_artifacts=$(ls .agent/FAIL-LOGS/ 2>/dev/null | wc -l || echo 0)
          rm -rf .agent
          
          # Compare results
          echo ""
          echo "Results:"
          echo "  Bash:       exit=$bash_exit, artifacts=$bash_artifacts"
          echo "  Python 3:   exit=$python_exit, artifacts=$python_artifacts"
          echo "  Perl:       exit=$perl_exit, artifacts=$perl_artifacts"
          
          # Validate parity
          drift=0
          
          if [ "$bash_exit" != "0" ] || [ "$python_exit" != "0" ] || [ "$perl_exit" != "0" ]; then
            echo "❌ DRIFT: Exit codes should all be 0"
            drift=1
          fi
          
          if [ "$bash_artifacts" != "0" ] || [ "$python_artifacts" != "0" ] || [ "$perl_artifacts" != "0" ]; then
            echo "❌ DRIFT: Artifact counts should all be 0"
            drift=1
          fi
          
          if [ $drift -eq 0 ]; then
            echo "✅ safe-run-001: All implementations match"
          else
            echo "❌ safe-run-001: DRIFT DETECTED"
            exit 1
          fi
      
      # Step 9: Run drift detection for safe-run-002 test vector
      # Test case: Failure scenario (exit 7, creates M0-format log)
      # Validates: Exit codes all 7, FAIL-LOGS created with correct markers
      # and naming pattern (YYYYMMDDTHHMMSSZ-pidPID-FAIL.log per M0-P1-I2)
      - name: Run drift detection - safe-run-002 (failure log format)
        id: drift-safe-run-002
        run: |
          echo "========================================="
          echo "Testing: safe-run-002 (failure creates log with M0 format)"
          echo "========================================="
          
          mkdir -p /tmp/drift-test-2
          cd /tmp/drift-test-2
          
          # Set SAFE_RUN_BIN for wrapper discovery (scripts run from outside repo)
          export SAFE_RUN_BIN="${GITHUB_WORKSPACE}/dist/linux/x86_64/safe-run"
          
          # Test Bash
          echo "Testing Bash implementation..."
          bash_exit=0
          bash "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/bash/scripts/safe-run.sh" bash -c 'echo OUT; echo ERR >&2; exit 7' > /tmp/bash-out2.txt 2>&1 || bash_exit=$?
          bash_log=$(ls .agent/FAIL-LOGS/*.log 2>/dev/null | head -1 || echo "")
          bash_has_stdout=$(grep -c "=== STDOUT ===" "$bash_log" 2>/dev/null || echo 0)
          bash_has_stderr=$(grep -c "=== STDERR ===" "$bash_log" 2>/dev/null || echo 0)
          bash_log_pattern="FAIL"
          if [ -n "$bash_log" ]; then
            basename "$bash_log" | grep -qE '^[0-9]{8}T[0-9]{6}Z-pid[0-9]+-FAIL\.log$' && bash_log_pattern="MATCH" || bash_log_pattern="NOMATCH"
          fi
          rm -rf .agent
          
          # Test Python 3
          echo "Testing Python 3 implementation..."
          python_exit=0
          python3 "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/python3/scripts/safe-run.py" python3 -c 'import sys; print("OUT"); print("ERR", file=sys.stderr); raise SystemExit(7)' > /tmp/python-out2.txt 2>&1 || python_exit=$?
          python_log=$(ls .agent/FAIL-LOGS/*.log 2>/dev/null | head -1 || echo "")
          python_has_stdout=$(grep -c "=== STDOUT ===" "$python_log" 2>/dev/null || echo 0)
          python_has_stderr=$(grep -c "=== STDERR ===" "$python_log" 2>/dev/null || echo 0)
          python_log_pattern="FAIL"
          if [ -n "$python_log" ]; then
            basename "$python_log" | grep -qE '^[0-9]{8}T[0-9]{6}Z-pid[0-9]+-FAIL\.log$' && python_log_pattern="MATCH" || python_log_pattern="NOMATCH"
          fi
          rm -rf .agent
          
          # Test Perl
          echo "Testing Perl implementation..."
          perl_exit=0
          perl "$GITHUB_WORKSPACE/RFC-Shared-Agent-Scaffolding-Example/scripts/perl/scripts/safe-run.pl" perl -e 'print "OUT\n"; print STDERR "ERR\n"; exit 7' > /tmp/perl-out2.txt 2>&1 || perl_exit=$?
          perl_log=$(ls .agent/FAIL-LOGS/*.log 2>/dev/null | head -1 || echo "")
          perl_has_stdout=$(grep -c "=== STDOUT ===" "$perl_log" 2>/dev/null || echo 0)
          perl_has_stderr=$(grep -c "=== STDERR ===" "$perl_log" 2>/dev/null || echo 0)
          perl_log_pattern="FAIL"
          if [ -n "$perl_log" ]; then
            basename "$perl_log" | grep -qE '^[0-9]{8}T[0-9]{6}Z-pid[0-9]+-FAIL\.log$' && perl_log_pattern="MATCH" || perl_log_pattern="NOMATCH"
          fi
          rm -rf .agent
          
          # Compare results
          echo ""
          echo "Results:"
          echo "  Bash:       exit=$bash_exit, stdout_marker=$bash_has_stdout, stderr_marker=$bash_has_stderr, log_pattern=$bash_log_pattern"
          echo "  Python 3:   exit=$python_exit, stdout_marker=$python_has_stdout, stderr_marker=$python_has_stderr, log_pattern=$python_log_pattern"
          echo "  Perl:       exit=$perl_exit, stdout_marker=$perl_has_stdout, stderr_marker=$perl_has_stderr, log_pattern=$perl_log_pattern"
          
          # Validate parity
          drift=0
          
          # All should exit with code 7
          if [ "$bash_exit" != "7" ] || [ "$python_exit" != "7" ] || [ "$perl_exit" != "7" ]; then
            echo "❌ DRIFT: Exit codes should all be 7"
            echo "   Bash: $bash_exit, Python: $python_exit, Perl: $perl_exit"
            drift=1
          fi
          
          # All should have stdout marker
          if [ "$bash_has_stdout" != "1" ] || [ "$python_has_stdout" != "1" ] || [ "$perl_has_stdout" != "1" ]; then
            echo "❌ DRIFT: All implementations should have === STDOUT === marker (M0-P1-I1)"
            echo "   Bash: $bash_has_stdout, Python: $python_has_stdout, Perl: $perl_has_stdout"
            drift=1
          fi
          
          # All should have stderr marker
          if [ "$bash_has_stderr" != "1" ] || [ "$python_has_stderr" != "1" ] || [ "$perl_has_stderr" != "1" ]; then
            echo "❌ DRIFT: All implementations should have === STDERR === marker (M0-P1-I1)"
            echo "   Bash: $bash_has_stderr, Python: $python_has_stderr, Perl: $perl_has_stderr"
            drift=1
          fi
          
          # All should match log naming pattern
          if [ "$bash_log_pattern" != "MATCH" ] || [ "$python_log_pattern" != "MATCH" ] || [ "$perl_log_pattern" != "MATCH" ]; then
            echo "❌ DRIFT: All implementations should follow M0-P1-I2 log naming format"
            echo "   Format: YYYYMMDDTHHMMSSZ-pidPID-FAIL.log"
            echo "   Bash: $bash_log_pattern, Python: $python_log_pattern, Perl: $perl_log_pattern"
            drift=1
          fi
          
          if [ $drift -eq 0 ]; then
            echo "✅ safe-run-002: All implementations match"
          else
            echo "❌ safe-run-002: DRIFT DETECTED"
            echo ""
            echo "This indicates behavioral divergence that violates M0 contract."
            echo "Review M2-P2-I1-DRIFT-DETECTION.md for resolution guidance."
            exit 1
          fi
      
      # Step 10: Print drift detection summary
      # Always runs (even if previous steps fail) to provide full diagnostic output
      # Conditional logic checks outcome of both test vectors
      - name: Drift detection summary
        if: always()
        run: |
          echo "========================================="
          echo "Drift Detection Summary"
          echo "========================================="
          echo ""
          echo "Tested vectors:"
          echo "  - safe-run-001: Success case (no artifacts)"
          echo "  - safe-run-002: Failure case (M0-P1-I1, M0-P1-I2 validation)"
          echo ""
          echo "Implementations tested:"
          echo "  - Bash"
          echo "  - Python 3"
          echo "  - Perl"
          echo ""
          echo "Note: PowerShell tests run on Windows runner separately"
          echo "      (not included in this Linux-based drift detection)"
          echo ""
          if [ "${{ steps.drift-safe-run-001.outcome }}" == "success" ] && [ "${{ steps.drift-safe-run-002.outcome }}" == "success" ]; then
            echo "✅ PASS: No drift detected. All implementations exhibit identical behavior."
          else
            echo "❌ FAIL: Drift detected. Review failures above."
            echo ""
            echo "Next steps:"
            echo "  1. Review M2-P2-I1-DRIFT-DETECTION.md"
            echo "  2. Determine if drift is a bug or acceptable difference"
            echo "  3. Fix implementation OR justify and document exception"
            exit 1
          fi
